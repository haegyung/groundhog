---
title: "Groundhog"
author:
  - name: "Patrick Hajjar"
    affiliation: "Friedrich-Alexander Universität Erlangen-Nürnberg (FAU)"
  - name: "Maximilian Held"
    affiliation: "Friedrich-Alexander Universität Erlangen-Nürnberg (FAU)"
  - name: "Ngoc Tuyet Nhung"
    affiliation: "Friedrich-Alexander Universität Erlangen-Nürnberg (FAU)"
  - name: "Eleni Sarri"
    affiliation: "Friedrich-Alexander Universität Erlangen-Nürnberg (FAU)"
  - name: "Valeria Scollo"
    affiliation: "Friedrich-Alexander Universität Erlangen-Nürnberg (FAU)"
date: "`r format(Sys.time(), '%d %B, %Y')`"
bibliography: library.bib
editor_options: 
  chunk_output_type: console
---

<div class="jumbotron" style="color:white; background: linear-gradient( rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.7) ), url(img/murray.jpg) no-repeat center center fixed; -webkit-background-size: cover; -moz-background-size: cover; -o-background-size: cover; background-size: cover;">
  <h2>Imagine you are in a time loop: What would you do?</h1>
  <p>A Q study on a thought experiment.</p>
  <p>
    <span class="label label-info">
      #GroundhogDay #rstats #QMethodology
    </span>
  </p>
  <p><small><sub>
    Image Credit: Groundhog Day (Columbia Pictures 1993), via [IMDB](https://www.imdb.com/title/tt0107048/)
  </sub></small></p>
</div>

```{r, child="README.rmd"}
```

```{r setup, include = FALSE}
library(readr)
library(magrittr)
library(fs)
library(purrr)
```


---

## Introduction

## Item Generation

### Q-Distribution

```{r include = FALSE}
distro <- qmethod::make.distribution(nstat = 59, max.bin = 7)
names(distro) <- -7:7
# TODO there is a bug here; this should work without specifiyng chessboard, null should default fine
grid <- pensieve::as_psGrid(obj = distro, pattern = "chessboard")
```

### Plotting Items

```{r, eval=FALSE, include=FALSE}
items <- readr::read_csv(file = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSkT1N44FpPcqAcAp1eChsHI0jlw-F0gqB7w1Sl4ksd6q3vNAoBbkjrx0rjlYc_7hhJiZ0uHvmxKRon/pub?gid=0&single=true&output=csv")
readr::write_rds(x = items, path = "items.rds")
```

```{r items, include = FALSE}
raw_items <- readr::read_rds(path = "items.rds")
items <- matrix(
  data = as.matrix(raw_items[,c("english", "german")]),
  nrow = nrow(raw_items),
  dimnames = list(items = raw_items$shorthandle, languages = c("english", "ngerman"))
)
# write out hashes and df
hash_de <- sapply(X = items[, "ngerman"], FUN = function(x) {
  digest::digest(object = x, algo = "crc32", serialize = FALSE)
})
hash_en <- sapply(X = items[, "english"], FUN = function(x) {
  digest::digest(object = x, algo = "crc32", serialize = FALSE)
})
input_helper_df <- data.frame(
  full_en = items[,"english"],
  full_de = items[,"ngerman"],
  handle = rownames(items),
  hash_en = hash_en,
  hash_de = hash_de
)
readr::write_csv(x = input_helper_df, path = "input_helper.csv")
```

```{r plot-items, eval=FALSE, include=FALSE}
library(qmethod)
qmethod::make.cards(
  q.set = items,
  study.language = "english", 
  output.pdf = TRUE, 
  babel.language = "english", 
  show.handles = FALSE, 
  duplex.double = TRUE, 
  wording.font.size = "\\large",
  file.name = "english")
qmethod::make.cards(
  q.set = items,
  study.language = "ngerman", 
  output.pdf = TRUE, 
  babel.language = "ngerman", 
  show.handles = FALSE, 
  duplex.double = TRUE, 
  wording.font.size = "\\large",
  file.name = "german")
```


## Field Work

Participants were given the following prompt:

> Imagine that, starting now, the next week will repeat itself once.
> In a week, the whole universe will rewind to today, all changes are undone and memories erased.
> You are the only person who knows this, and you alone will remember what happened during this week.
> What would you do?
>
> Rank the following items according to your likelihood for enacting them in the next week.
> Rank all activities highly which you like, even if you could not complete them all in the given time.
>
> Remember that whatever you do in the next seven days would be completely undone at the end of the week; only your memories remain.


Or, in German:

> Stelle dir vor, dass sich die nächste Woche genau ein Mal wiederholt.
> Am Ende der Woche dreht sich die Zeit zurück auf den heutigen Tag. Alle Veränderungen sind revidiert und Erinnerungen gelöscht.
> Du bist die einzige Person, die über diese Wiederholung weiß und nur du kannst dich in Zukunft daran erinnern, was in der Woche passiert ist.
>
> Sortiere die folgenden Aktivitäten danach, wie wahrscheinlich du sie in der Woche durchführen würdest.
> Es ist nicht wichtig, ob du die präferierten Aktivitäten auch alle schaffen könntest.
>
> Denke daran, dass alle Änderungen im Universum am Ende der Woche rückgängig gemacht werden; nur deine Erinnerungen bleiben.


Participants were given the following sorting instructions:

> 1. Choose a pseudonym, so that you can recognize your own datapoints in the results.
    ![](img/pseudo.jpg)
> 1. Read through all the items carefully. 
     Make notes on the items if you like.
> 2. Preliminarily sort the items into three piles:
     1. Items you like.
     2. Items you do not understand or are ambivalent about.
     3. Items you dislike.
     ![](img/presort.jpg)
> 3. Rank-order the items according to how likely you are to do the described activities, from the right (likely to do) to the left (unlikely to do).
      Start with items from the right (likely to do), continue with items from the left (unlikely to do), and finally fill in the middle (ambivalent).
> 4. Consider your completed sort, and revise item positions if necessary.
      ![](img/sort.jpg)
> 5. Add comments to items you feel strongly about, or do not understand.
> 6. Turn all items on their back (only showing a random string), and ask the investigator to take a picture of your completed sort.
    ![](img/codes.jpg)


Participants were reminded:

> - There is no correct or consistent way to complete your Q sort; whatever you feel expresses your subjective view on the matter is correct. 
>   This is not a test - There is no "right answer".
> - Only the horizontal dimension (from left to right) matters; the vertical axis does not matter.
  Items on top of one another merely express ties.
> If you are ambivalent about an item or do not understand it, place it in the middle between the two extremes.
  This is valuable information, too.
> - You must place all items.
> - You must adhere to the distribution.
> - Only *relative* positions matter.
    For example, you may feel positively about *more* than half of the items, and have only very few neutral or negative items.


Important notes for **the investigators**:

- Remember to sample a *diverse* group of people who are likely to display *different* viewpoints on the subject matter.
- We are not going to gather *any* personal data.
  Make sure not to pollute the gathered data with any information that might deanonymize your participants.
  For example *do not* record their email adress on the cards, and make sure that their pseudonyms are properly anonymous.
  If you want to email the results to the participants, store their contact information *separately* and securely, with no reference to the study.
- **Make sure to test the photo you're taking at the end to record the sort**: 
    - Are the item codes legible? 
    - Is the lighting ok?
    - Is the resolution high enough?
    - Is the pseudonym card in the picture?
    - Save several copies of these images.
    - (If possible, delete date and location metadata from these images).
- There may be a tradeoff in our study between a) getting deep, qualitative insights from observing and discussing the sorting behavior and b) avoiding social desirability biases.
  Participants may not feel free to sort some items (e.g. anti-social and sexual), when they are closely observed, or know that the investigator (= you), will "know" their Q sort.
  (For this reason, the item backs are marked with arbitrary codes for identification, so that participants never have to "show" their sorts to the investigators.)
  It's not clear what we should do here, because on the other hand, we probably cannot produce proper anonymity in in-person sorts, and we may also want to closely observe and engage the participants.
- Take the time to carefully discuss the sorting procedure with participants after they are done.
  If you want to (see above caveat), also sit next to them while they sort and prompt them to explain their choices.
  **Take notes!**
- Remind participants to add feedback or any thoughts and comments to the items.
  They can write them on the cards.
  **Provide participants with pens or pencils.**
- When you are preparing the cards, make sure that every participant has a complete set (and no duplicates). 
  This can be quite difficult and requires *very* careful preparation (envelopes are useful).
- Explain the procedure very carefully to the participants, and **show them pictures of the completed sorts**.
  Otherwise, it can be quite hard to understand the methodology.
  In particular, remind them that only the horizontal axis matters, what the extremes are, and that they must adhere to the forced distribution.
- This procedure takes time and some quiet patience (> 60 minutes), as well as some space (e.g. a free table).
  Plan accordingly.


### Gathered Data

- Max gathered **2** sorts. [^ownsort]
- Patrick gathered **8** sorts. [^ownsort]
- Eleni gathered **8** sorts. [^ownsort]
- Valeria gathered **9** sorts.
- Maria gathered **6** sorts.

[^ownsort]: This includes one sort completed by the author himself.

```{r data-import, include=FALSE, eval=FALSE}
library(googlesheets)
# this is the sheet
groundhog_entry <- gs_title(x = "groundhog-entry", verbose = TRUE)
gs_read(ss = groundhog_entry, ws = "Item Feedback", range = "C1:R60", col_names = TRUE) %>% 
  write_csv(path = "rawdat/item_feedback.csv", append = FALSE, col_names = TRUE)
all_ws <- gs_ws_ls(groundhog_entry)
parts <- all_ws[!(all_ws %in% c("input_helper", "input-template", "Item Feedback"))]
walk(.x = parts, .f = function(x) {
  gs_read(ss = groundhog_entry, ws = x, range = c("A3:O9"), col_names = as.character(-7:7), na = c("#N/A")) %>% 
    write_csv(path = fs::path("rawdat", "sorts", x, ext = "csv"), append = FALSE, col_names = TRUE)
})
```

```{r data-cleaning, include = FALSE}
# rootsorts <- fs::path("..", "groundhog", "rawdat", "sorts")
library(pensieve)
lookup <- readr::read_csv(file = "input_helper.csv")
rootsorts <- fs::path("rawdat", "sorts")
filenames <- fs::dir_ls(rootsorts, recursive = FALSE, all = FALSE, type = "file", glob = "*.csv")
persons <- fs::path_file(filenames)
persons <- fs::path_ext_remove(persons)
rawdat <- purrr::map(.x = persons, .f = function(x) {
  cat(x)
  path <- fs::path(rootsorts, x, ext = "csv")
  thissort <- readr::read_csv(file = path, col_names = TRUE)
  thissort <- as.matrix(thissort)
  # TODO hackfix
  attr(thissort, "pattern") <- "chessboard"
  class(thissort) <- c("psSort", "matrix")
  thissort <- pensieve::import_psSort(x = thissort, grid = grid, lookup = lookup)
  thissort <- tidyr::gather(tibble::as_tibble(thissort), na.rm = TRUE)
  return(thissort)
})
names(rawdat) <- make.names(persons)
library(dplyr)
qdat <- purrr::reduce(.x = rawdat, .f = left_join, by = "value")
item_order <- qdat$value
qdat$value <- NULL
qdat <- as.matrix(qdat)
rownames(qdat) <- item_order
colnames(qdat) <- make.names(persons)
qdat[,] <- as.integer(qdat)
storage.mode(x = qdat) <- "integer"
```

```{r correlations, fig.height=15, fig.width=15, fig.cap="Correlations"}
res <- NULL
res$corr <- cor(x = qdat, method = "spearman")
qmethod::q.corrplot(corr.matrix = res$corr)
plot(pensieve::QCors(cors = res$corr))
```

```{r paran, fig.height=15, fig.width=7, fig.cap="Parallel Analysis"}
qmethod::q.nfactors(dataset = qdat, iterations = 10000, cutoff = 8, cor.method = "spearman", siglevel = 0.5)
```

```{r paran2}
pensieve_paran <- pensieve::run_parallel(dataset = qdat, centile = .5, grid = distro)
qres <- qmethod::qmethod(dataset = qdat, nfactors = 5, rotation = "none")
qres$f_char$characteristics$eigenvals[1:5] - pensieve_paran[1:5]
```

```{r rotations}
unrot <- qmethod::qmethod(dataset = qdat, nfactors = 3, rotation = "varimax", forced = TRUE, cor.method = "spearman", reorder = FALSE, threshold = "none", allow.confounded = TRUE)
unrot$f_char
qmethod::q.loaplot(results = unrot) # works
qmethod::q.scoreplot.num(results = unrot) # works
qmethod::q.scoreplot.ord(results = unrot, factor = 1)  # works
# qmethod::q.compplot(results = unrot)
# qmethod::q.rotplot(results = unrot)
```


## Analysis


## Interpretation

### Factor 1
<!-- TODO add proper factor names as heading -->
This is just to provoke a merge conflict!

### Factor 2


### Factor 3



## Conclusion


## References
